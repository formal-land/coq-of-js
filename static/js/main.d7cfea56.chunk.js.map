{"version":3,"sources":["compiler/monad.js","compiler/result.js","compiler/doc.js","compiler/identifier.js","compiler/typ.js","compiler/util.js","compiler/expression.js","compiler/typ-definition.js","compiler/top-level-statement.js","compiler/program.js","demoInput.js","Output.js","App.js","compiler/error.js","serviceWorker.js","index.js"],"names":["ret","all","raise","raiseUnhandled","value","expressions","type","reduce","array","accumulator","reducer","a","element","filterMap","f","result","some","predicate","areSome","node","message","JSON","stringify","runWithAnswer","expression","answer","next","done","nextAnswer","results","errors","Result","map","location","loc","doc","builders","concat","group","hardline","indent","join","line","softline","paren","needParens","nameMapping","Props","compile","identifier","name","getObjectKeyName","compileIdentifier","compileIfHandled","key","Identifier","Monad","compileIdentifierOrQualifiedTypeIdentifier","id","qualification","typ","properties","length","printImplicitTyps","names","Doc","print","getObjectPropertyName","getLeftValueRecordFields","compileLVal","getStringOfStringLiteral","getFieldsDestructuringFromHeadStatement","compileStatements","compileFun","tt","property","Typ","pattern","variable","lval","typeAnnotation","typName","fields","record","isEmptyDefaultBranch","statements","statement","body","argument","discriminantName","noDestructuring","trailingStatements","headStatement","slice","declarations","declaration","init","discriminant","object","sum","cases","consequent","test","branches","defaultCase","find","branch","defaultBranch","accumulatedNames","currentAccumulatedNames","fun","returnTyp","returnType","params","param","typeParameters","Util","arguments","typParameters","elements","left","operator","right","callee","alternate","field","computed","constr","instance","printFunArguments","funArguments","printRecordInstance","printLeftValue","withQuote","printMatch","patterns","getObjectTypePropertyName","getStringOfStringLiteralTypeAnnotation","compileStringEnum","compileSumType","typs","nameProperties","fieldProperties","constructors","plainTyp","types","printModule","printRecord","printDefineTypeAsModule","extractIdentifierOfLVal","Expression","source","TypDefinition","impltype","typDefinition","nextToken","module","constructor","program","TopLevelStatement","unflattenedStatements","CoqOutput","output","this","props","PureComponent","getInitialJsInput","window","item","sessionStorage","getItem","demoInput","App","state","jsInput","onChangeJsInput","event","currentTarget","setState","setItem","parse","plugins","sourceType","error","codeFrame","column","jsAst","Program","errorSourceCode","codeFrameColumns","Error","coqAst","printer","printDocToString","withHeader","programElement","printWidth","tabWidth","formatted","getJsAst","coq","getCoqAst","getCoqString","getOutputs","className","aria-label","role","href","onChange","Boolean","hostname","match","rootElement","document","getElementById","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d7cfea56.chunk.js","sourcesContent":["// @flow\n// This monad is used internally by the compiler. It handles the user errors.\n// In contrast to exceptions, it supports one or many errors. Thus the user\n// may get all the errors found by the compiler at once.\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Result from \"./result.js\";\n\ntype Yield =\n  | {\n      type: \"All\",\n      expressions: Generator<Yield, any, any>[],\n    }\n  | {\n      type: \"Raise\",\n      message: string,\n      node: BabelAst.Node,\n    };\n\nexport type t<A> = Generator<Yield, A, any>;\n\n// eslint-disable-next-line require-yield\nexport function* ret<A>(value: A): t<A> {\n  return value;\n}\n\n// Evaluate an array of expressions.\n// Keep all the errors in case there are many.\nexport function* all<A>(expressions: t<A>[]): t<A[]> {\n  return yield {type: \"All\", expressions};\n}\n\nexport function reduce<Accumulator, A>(\n  array: A[],\n  accumulator: Accumulator,\n  reducer: (accumulator: Accumulator, element: A) => t<Accumulator>,\n): t<Accumulator> {\n  return array.reduce(function*(accumulator, element) {\n    return yield* reducer(yield* accumulator, element);\n  }, ret(accumulator));\n}\n\nexport function filterMap<A, B>(array: A[], f: (element: A) => t<?B>): t<B[]> {\n  return reduce(array, [], function*(accumulator: B[], element) {\n    const result = yield* f(element);\n\n    return result ? [...accumulator, result] : accumulator;\n  });\n}\n\nexport function some<A>(\n  array: A[],\n  predicate: (element: A) => t<boolean>,\n): t<boolean> {\n  return reduce(array, false, function*(areSome, element) {\n    return areSome || (yield* predicate(element));\n  });\n}\n\nexport function* raise<A>(node: BabelAst.Node, message: string): t<A> {\n  return yield {type: \"Raise\", message, node};\n}\n\nexport function* raiseUnhandled<A>(node: BabelAst.Node): t<A> {\n  return yield* raise<A>(\n    node,\n    `Unhandled syntax:\\n${JSON.stringify(node, null, 2)}`,\n  );\n}\n\nfunction runWithAnswer<A>(expression: t<A>, answer?: any): Result.t<any> {\n  const result = expression.next(answer);\n\n  if (result.done) {\n    return {\n      type: \"Success\",\n      value: result.value,\n    };\n  }\n\n  const nextAnswer: Result.t<any> = (() => {\n    switch (result.value.type) {\n      case \"All\": {\n        const results = result.value.expressions.map(expression =>\n          runWithAnswer(expression),\n        );\n\n        return Result.merge(results);\n      }\n      case \"Raise\": {\n        const error = {\n          location: result.value.node.loc,\n          message: result.value.message,\n        };\n\n        return {type: \"Error\", errors: [error]};\n      }\n      /* istanbul ignore next */\n      default:\n        return result.value;\n    }\n  })();\n\n  switch (nextAnswer.type) {\n    case \"Error\":\n      return nextAnswer;\n    case \"Success\":\n      return runWithAnswer(expression, nextAnswer.value);\n    /* istanbul ignore next */\n    default:\n      return nextAnswer;\n  }\n}\n\nexport function run<A>(expression: t<A>): Result.t<A> {\n  return runWithAnswer(expression);\n}\n","// @flow\nimport * as Error from \"./error.js\";\n\nexport type t<A> =\n  | {\n      type: \"Error\",\n      errors: Error.t[],\n    }\n  | {\n      type: \"Success\",\n      value: A,\n    };\n\nexport function merge<A>(results: t<A>[]): t<A[]> {\n  return results.reduce(\n    (accumulator: t<A[]>, result: t<A>) => {\n      switch (accumulator.type) {\n        case \"Error\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: [...accumulator.errors, ...result.errors],\n              };\n            case \"Success\":\n              return {\n                type: \"Error\",\n                errors: accumulator.errors,\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        case \"Success\":\n          switch (result.type) {\n            case \"Error\":\n              return {\n                type: \"Error\",\n                errors: result.errors,\n              };\n            case \"Success\":\n              return {\n                type: \"Success\",\n                value: [...accumulator.value, result.value],\n              };\n            /* istanbul ignore next */\n            default:\n              return result;\n          }\n        /* istanbul ignore next */\n        default:\n          return accumulator;\n      }\n    },\n    {type: \"Success\", value: []},\n  );\n}\n","// @flow\n// A wrapper around Prettier doc primitives.\nimport doc from \"prettier/doc.js\";\n\ndeclare opaque type Doc;\n\nexport type t = Doc | string;\n\nconst {\n  concat,\n  group,\n  hardline,\n  indent,\n  join,\n  line,\n  softline,\n}: {\n  concat: (docs: $ReadOnlyArray<t>) => t,\n  group: (doc: t) => t,\n  hardline: t,\n  indent: (doc: t) => t,\n  join: (sep: t, docs: $ReadOnlyArray<t>) => t,\n  line: t,\n  softline: t,\n} = doc.builders;\n\nexport {concat, group, hardline, indent, join, line, softline};\n\nexport function paren(needParens: boolean, doc: t): t {\n  return needParens ? group(concat([\"(\", doc, \")\"])) : doc;\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\n\nconst nameMapping: {[name: string]: string} = {\n  Props: \"_Props\",\n};\n\nexport function compile(identifier: BabelAst.Identifier): string {\n  const {name} = identifier;\n\n  return nameMapping[name] || name;\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\n\nexport type t = {\n  type: \"Variable\",\n  name: string,\n};\n\nexport function* getObjectKeyName(key: any): Monad.t<string> {\n  switch (key.type) {\n    case \"Identifier\":\n      return Identifier.compile(key);\n    case \"StringLiteral\":\n      return key.value;\n    default:\n      return yield* Monad.raise<string>(key, \"Computed key name not handled\");\n  }\n}\n\nfunction compileIdentifierOrQualifiedTypeIdentifier(\n  id: BabelAst.Identifier | BabelAst.QualifiedTypeIdentifier,\n): string {\n  switch (id.type) {\n    case \"Identifier\":\n      return Identifier.compile(id);\n    case \"QualifiedTypeIdentifier\":\n      return `${compileIdentifierOrQualifiedTypeIdentifier(\n        id.qualification,\n      )}.${Identifier.compile(id.id)}`;\n    /* istanbul ignore next */\n    default:\n      return id;\n  }\n}\n\nexport function* compileIdentifier(typ: BabelAst.FlowType): Monad.t<string> {\n  switch (typ.type) {\n    case \"GenericTypeAnnotation\":\n      return compileIdentifierOrQualifiedTypeIdentifier(typ.id);\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a type identifier\");\n  }\n}\n\nexport function* compileIfHandled(typ: BabelAst.FlowType): Monad.t<?t> {\n  switch (typ.type) {\n    case \"BooleanLiteralTypeAnnotation\":\n      return yield* Monad.raise<?t>(\n        typ,\n        \"Boolean literals in types are not handled\",\n      );\n    case \"BooleanTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"bool\",\n      };\n    case \"EmptyTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"Empty_set\",\n      };\n    case \"GenericTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: compileIdentifierOrQualifiedTypeIdentifier(typ.id),\n      };\n    case \"NullLiteralTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"unit\",\n      };\n    case \"NumberLiteralTypeAnnotation\":\n      return yield* Monad.raise<?t>(\n        typ,\n        \"Number literals in types are not handled\",\n      );\n    case \"NumberTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"Z\",\n      };\n    case \"ObjectTypeAnnotation\": {\n      if (typ.properties.length === 0) {\n        return {\n          type: \"Variable\",\n          name: \"unit\",\n        };\n      }\n\n      return null;\n    }\n    case \"StringTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"string\",\n      };\n    case \"VoidTypeAnnotation\":\n      return {\n        type: \"Variable\",\n        name: \"unit\",\n      };\n    default:\n      return null;\n  }\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  return (\n    (yield* compileIfHandled(typ)) || (yield* Monad.raiseUnhandled<t>(typ))\n  );\n}\n\nexport function printImplicitTyps(names: string[]): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{\",\n      Doc.indent(\n        Doc.concat([\n          Doc.softline,\n          Doc.join(Doc.line, names),\n          Doc.line,\n          Doc.group(Doc.concat([\":\", Doc.line, \"Type\"])),\n        ]),\n      ),\n      Doc.softline,\n      \"}\",\n    ]),\n  );\n}\n\nexport function print(typ: t): Doc.t {\n  switch (typ.type) {\n    case \"Variable\":\n      return typ.name;\n    /* istanbul ignore next */\n    default:\n      return typ;\n  }\n}\n\nexport function printReturnTyp(typ: ?t, nextToken: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      ...(typ ? [\":\", Doc.line, print(typ), Doc.line] : []),\n      nextToken,\n    ]),\n  );\n}\n","// @flow\n\nexport function filterMap<A, B>(array: A[], f: (element: A) => ?B): B[] {\n  return array.reduce((accumulator: B[], element) => {\n    const result = f(element);\n\n    return result ? [...accumulator, result] : accumulator;\n  }, []);\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype LeftValueRecordField = {\n  name: string,\n  variable: string,\n};\n\ntype LeftValue =\n  | {\n      type: \"Record\",\n      fields: LeftValueRecordField[],\n      record: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type t =\n  | {\n      type: \"ArrayExpression\",\n      elements: t[],\n    }\n  | {\n      type: \"BinaryExpression\",\n      left: t,\n      operator: string,\n      right: t,\n    }\n  | {\n      type: \"CallExpression\",\n      arguments: t[],\n      callee: t,\n    }\n  | {\n      type: \"ConditionalExpression\",\n      alternate: t,\n      consequent: t,\n      test: t,\n    }\n  | {\n      type: \"Constant\",\n      value: boolean | number | string,\n    }\n  | {\n      type: \"EnumDestruct\",\n      branches: {body: t, names: string[]}[],\n      defaultBranch: ?t,\n      discriminant: t,\n      typName: string,\n    }\n  | {\n      type: \"EnumInstance\",\n      instance: string,\n      typName: string,\n    }\n  | {\n      type: \"FunctionExpression\",\n      // eslint-disable-next-line no-use-before-define\n      value: Fun,\n    }\n  | {\n      type: \"Let\",\n      body: t,\n      lval: LeftValue,\n      value: t,\n    }\n  | {\n      type: \"RecordInstance\",\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      record: string,\n    }\n  | {\n      type: \"RecordProjection\",\n      field: string,\n      object: t,\n      record: string,\n    }\n  | {\n      type: \"SumDestruct\",\n      branches: {body: t, fields: LeftValueRecordField[], name: string}[],\n      defaultBranch: ?t,\n      discriminant: t,\n      sum: string,\n    }\n  | {\n      type: \"SumInstance\",\n      constr: string,\n      // eslint-disable-next-line no-use-before-define\n      fields: RecordField[],\n      sum: string,\n    }\n  | {\n      type: \"TypeCastExpression\",\n      expression: t,\n      typeAnnotation: Typ.t,\n    }\n  | {\n      type: \"UnaryExpression\",\n      argument: t,\n      operator: string,\n    }\n  | {\n      type: \"Variable\",\n      name: string,\n    };\n\nexport type FunArgument = {\n  name: string,\n  typ: ?Typ.t,\n};\n\nexport type Fun = {\n  arguments: FunArgument[],\n  body: t,\n  returnTyp: ?Typ.t,\n  typParameters: string[],\n};\n\ntype RecordField = {\n  name: string,\n  value: t,\n};\n\nexport const tt: t = {\n  type: \"Variable\",\n  name: \"tt\",\n};\n\nfunction* getObjectPropertyName(\n  property: BabelAst.ObjectProperty,\n): Monad.t<string> {\n  return yield* Typ.getObjectKeyName(property.key);\n}\n\nfunction* getLeftValueRecordFields(\n  pattern: BabelAst.ObjectPattern,\n): Monad.t<LeftValueRecordField[]> {\n  return yield* Monad.all(\n    pattern.properties.map(function*(property) {\n      switch (property.type) {\n        case \"ObjectProperty\":\n          switch (property.value.type) {\n            case \"Identifier\": {\n              const {value} = property;\n\n              return {\n                name: yield* getObjectPropertyName(property),\n                variable: Identifier.compile(value),\n              };\n            }\n            default:\n              return yield* Monad.raise<LeftValueRecordField>(\n                property.value,\n                \"Expected an identifier\",\n              );\n          }\n        case \"RestElement\":\n          return yield* Monad.raise<LeftValueRecordField>(\n            property,\n            \"Unhandled rest element for record destructuring\",\n          );\n        /* istanbul ignore next */\n        default:\n          return property;\n      }\n    }),\n  );\n}\n\nfunction* compileLVal(lval: BabelAst.LVal): Monad.t<LeftValue> {\n  switch (lval.type) {\n    case \"ArrayPattern\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unhandled array patterns\");\n    /* istanbul ignore next */\n    case \"AssignmentPattern\":\n      return yield* Monad.raise<LeftValue>(\n        lval,\n        \"Unexpected assignment patterns\",\n      );\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: Identifier.compile(lval),\n      };\n    /* istanbul ignore next */\n    case \"MemberExpression\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unexpected member access\");\n    case \"ObjectPattern\": {\n      const typName = lval.typeAnnotation\n        ? yield* Typ.compileIdentifier(lval.typeAnnotation.typeAnnotation)\n        : yield* Monad.raise<string>(\n            lval,\n            \"Expected a type annotation for record destructuring\",\n          );\n      const fields = yield* getLeftValueRecordFields(lval);\n\n      return {\n        type: \"Record\",\n        fields,\n        record: typName,\n      };\n    }\n    /* istanbul ignore next */\n    case \"RestElement\":\n      return yield* Monad.raise<LeftValue>(lval, \"Unexpected rest elements\");\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nfunction* getStringOfStringLiteral(\n  expression: BabelAst.Expression,\n): Monad.t<string> {\n  switch (expression.type) {\n    case \"StringLiteral\":\n      return expression.value;\n    default:\n      return yield* Monad.raise<string>(\n        expression,\n        \"Expected a string literal\",\n      );\n  }\n}\n\nfunction isEmptyDefaultBranch(statements: BabelAst.Statement[]): boolean {\n  if (statements.length >= 1) {\n    const statement = statements[0];\n    switch (statement.type) {\n      case \"BlockStatement\":\n        return isEmptyDefaultBranch(statement.body);\n      case \"ReturnStatement\":\n        if (statement.argument) {\n          switch (statement.argument.type) {\n            case \"TypeCastExpression\":\n              switch (statement.argument.typeAnnotation.typeAnnotation.type) {\n                case \"EmptyTypeAnnotation\":\n                  return true;\n                default:\n                  return false;\n              }\n            default:\n              return false;\n          }\n        }\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\ntype FieldsDestructuringFromHeadStatement = {\n  fields: LeftValueRecordField[],\n  trailingStatements: BabelAst.Statement[],\n};\n\nfunction* getFieldsDestructuringFromHeadStatement(\n  statements: BabelAst.Statement[],\n  discriminantName: string,\n): Monad.t<FieldsDestructuringFromHeadStatement> {\n  const noDestructuring = {fields: [], trailingStatements: statements};\n\n  if (statements.length === 0) {\n    return noDestructuring;\n  }\n\n  const headStatement = statements[0];\n\n  switch (headStatement.type) {\n    case \"BlockStatement\":\n      return yield* getFieldsDestructuringFromHeadStatement(\n        [...headStatement.body, ...statements.slice(1)],\n        discriminantName,\n      );\n    case \"VariableDeclaration\": {\n      if (headStatement.declarations.length !== 1) {\n        return yield* Monad.raise<FieldsDestructuringFromHeadStatement>(\n          headStatement,\n          \"Expected a single definition of variable\",\n        );\n      }\n\n      const declaration = headStatement.declarations[0];\n\n      if (declaration.init) {\n        switch (declaration.init.type) {\n          case \"Identifier\": {\n            const {name} = declaration.init;\n\n            if (name === discriminantName) {\n              switch (declaration.id.type) {\n                case \"ObjectPattern\": {\n                  const fields = yield* getLeftValueRecordFields(\n                    declaration.id,\n                  );\n\n                  return {\n                    fields,\n                    trailingStatements: statements.slice(1),\n                  };\n                }\n                default:\n                  return yield* Monad.raise<FieldsDestructuringFromHeadStatement>(\n                    declaration.id,\n                    \"Expected an object pattern to destructure a sum type\",\n                  );\n              }\n            }\n\n            return noDestructuring;\n          }\n          default:\n            return noDestructuring;\n        }\n      }\n\n      return noDestructuring;\n    }\n    default:\n      return noDestructuring;\n  }\n}\n\nexport function* compileStatements(\n  statements: BabelAst.Statement[],\n): Monad.t<t> {\n  if (statements.length === 0) {\n    return tt;\n  }\n\n  const statement = statements[0];\n\n  switch (statement.type) {\n    case \"BlockStatement\":\n      return yield* compileStatements([\n        ...statement.body,\n        ...statements.slice(1),\n      ]);\n    case \"ReturnStatement\":\n      return statement.argument ? yield* compile(statement.argument) : tt;\n    case \"SwitchStatement\":\n      switch (statement.discriminant.type) {\n        // Destructuring of sum type.\n        case \"MemberExpression\": {\n          const {discriminant} = statement;\n          const field = yield* Typ.getObjectKeyName(discriminant.property);\n\n          if (field !== \"type\") {\n            return yield* Monad.raise<t>(\n              discriminant.property,\n              \"Expected an access on the `type` field to destructure a sum type\",\n            );\n          }\n\n          switch (discriminant.object.type) {\n            case \"TypeCastExpression\": {\n              const {expression, typeAnnotation} = discriminant.object;\n              const sum = yield* Typ.compileIdentifier(\n                typeAnnotation.typeAnnotation,\n              );\n\n              switch (expression.type) {\n                case \"Identifier\": {\n                  const discriminantName = expression.name;\n                  const branches = yield* Monad.filterMap(\n                    statement.cases,\n                    function*({consequent, test}) {\n                      if (!test) {\n                        return null;\n                      }\n\n                      const {\n                        fields,\n                        trailingStatements,\n                      } = yield* getFieldsDestructuringFromHeadStatement(\n                        consequent,\n                        discriminantName,\n                      );\n\n                      return {\n                        body: yield* compileStatements(trailingStatements),\n                        fields,\n                        name: yield* getStringOfStringLiteral(test),\n                      };\n                    },\n                  );\n                  const defaultCase =\n                    statement.cases.find(\n                      branch =>\n                        !branch.test &&\n                        !isEmptyDefaultBranch(branch.consequent),\n                    ) || null;\n\n                  return {\n                    type: \"SumDestruct\",\n                    branches,\n                    defaultBranch:\n                      defaultCase &&\n                      (yield* compileStatements(defaultCase.consequent)),\n                    discriminant: yield* compile(expression),\n                    sum,\n                  };\n                }\n                default:\n                  return yield* Monad.raise<t>(\n                    expression,\n                    \"Expected a switch on an identifier to destructure a sum type\",\n                  );\n              }\n            }\n            default:\n              return yield* Monad.raise<t>(\n                discriminant.object,\n                \"Expected a type annotation on this expression to destructure a sum type\",\n              );\n          }\n        }\n        // Destructuring of enum.\n        case \"TypeCastExpression\": {\n          const {expression, typeAnnotation} = statement.discriminant;\n          const {accumulatedNames, branches} = yield* Monad.reduce<\n            {\n              accumulatedNames: string[],\n              branches: {body: t, names: string[]}[],\n            },\n            BabelAst.SwitchCase,\n          >(statement.cases, {accumulatedNames: [], branches: []}, function*(\n            {accumulatedNames, branches},\n            branch,\n          ) {\n            if (!branch.test) {\n              return {accumulatedNames: [], branches};\n            }\n\n            const name = yield* getStringOfStringLiteral(branch.test);\n            const currentAccumulatedNames = [...accumulatedNames, name];\n\n            if (branch.consequent.length === 0) {\n              return {accumulatedNames: currentAccumulatedNames, branches};\n            }\n\n            return {\n              accumulatedNames: [],\n              branches: [\n                ...branches,\n                {\n                  body: yield* compileStatements(branch.consequent),\n                  names: currentAccumulatedNames,\n                },\n              ],\n            };\n          });\n          const defaultCase =\n            statement.cases.find(\n              branch =>\n                !branch.test && !isEmptyDefaultBranch(branch.consequent),\n            ) || null;\n\n          return {\n            type: \"EnumDestruct\",\n            branches: [\n              ...branches,\n              ...(accumulatedNames.length !== 0\n                ? [{body: tt, names: accumulatedNames}]\n                : []),\n            ],\n            defaultBranch:\n              defaultCase && (yield* compileStatements(defaultCase.consequent)),\n            discriminant: yield* compile(expression),\n            typName: yield* Typ.compileIdentifier(\n              typeAnnotation.typeAnnotation,\n            ),\n          };\n        }\n        default:\n          return yield* Monad.raise<t>(\n            statement.discriminant,\n            \"Missing type annotation to destructure an enum\",\n          );\n      }\n    case \"VariableDeclaration\": {\n      if (statement.declarations.length !== 1) {\n        return yield* Monad.raise<t>(\n          statement,\n          \"Expected exactly one definition\",\n        );\n      }\n\n      const declaration = statement.declarations[0];\n\n      return {\n        type: \"Let\",\n        body: yield* compileStatements(statements.slice(1)),\n        lval: yield* compileLVal(declaration.id),\n        value: declaration.init\n          ? yield* compile(declaration.init)\n          : yield* Monad.raise<t>(\n              declaration,\n              \"Expected a definition with a value\",\n            ),\n      };\n    }\n    default:\n      return yield* Monad.raiseUnhandled<t>(statement);\n  }\n}\n\nexport function* compileFun(\n  fun:\n    | BabelAst.FunctionDeclaration\n    | BabelAst.FunctionExpression\n    | BabelAst.ArrowFunctionExpression,\n): Monad.t<Fun> {\n  const returnTyp = fun.returnType ? fun.returnType.typeAnnotation : null;\n\n  return {\n    arguments: yield* Monad.all(\n      fun.params.map(function*(param) {\n        switch (param.type) {\n          case \"Identifier\":\n            return {\n              name: param.name,\n              typ: param.typeAnnotation\n                ? yield* Typ.compile(param.typeAnnotation.typeAnnotation)\n                : null,\n            };\n          default:\n            return yield* Monad.raise<FunArgument>(\n              param,\n              \"Expected simple identifier as function parameter\",\n            );\n        }\n      }),\n    ),\n    body:\n      fun.body.type === \"BlockStatement\"\n        ? yield* compileStatements(fun.body.body)\n        : yield* compile(fun.body),\n    returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n    typParameters: fun.typeParameters\n      ? Util.filterMap(fun.typeParameters.params, param => param.name)\n      : [],\n  };\n}\n\nexport function* compile(expression: BabelAst.Expression): Monad.t<t> {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      return {\n        type: \"ArrayExpression\",\n        elements: expression.elements\n          ? yield* Monad.all(\n              expression.elements.map(function*(element) {\n                if (!element) {\n                  return yield* Monad.raise<t>(\n                    expression,\n                    \"Expected non-empty elements in the array\",\n                  );\n                }\n\n                if (element.type === \"SpreadElement\") {\n                  return yield* Monad.raise<t>(\n                    element,\n                    \"Spreads in arrays are not handled\",\n                  );\n                }\n\n                return yield* compile(element);\n              }),\n            )\n          : /* istanbul ignore next */\n            yield* Monad.raise<t[]>(\n              expression,\n              \"Unexpected empty array expression\",\n            ),\n      };\n    case \"ArrowFunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"BinaryExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"BooleanLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"CallExpression\":\n      return {\n        type: \"CallExpression\",\n        arguments: yield* Monad.all(\n          expression.arguments.map(function*(argument) {\n            switch (argument.type) {\n              case \"ArgumentPlaceholder\":\n                return yield* Monad.raise<t>(\n                  argument,\n                  \"Unhandled partial application\",\n                );\n              case \"SpreadElement\":\n                return yield* Monad.raise<t>(\n                  argument,\n                  \"Unhandled spread parameters\",\n                );\n              default:\n                return yield* compile(argument);\n            }\n          }),\n        ),\n        callee: yield* compile(expression.callee),\n      };\n    case \"ConditionalExpression\":\n      return {\n        type: \"ConditionalExpression\",\n        alternate: yield* compile(expression.alternate),\n        consequent: yield* compile(expression.consequent),\n        test: yield* compile(expression.test),\n      };\n    case \"FunctionExpression\":\n      return {\n        type: \"FunctionExpression\",\n        value: yield* compileFun(expression),\n      };\n    case \"Identifier\":\n      return {\n        type: \"Variable\",\n        name: expression.name,\n      };\n    case \"LogicalExpression\":\n      return {\n        type: \"BinaryExpression\",\n        left: yield* compile(expression.left),\n        operator: expression.operator,\n        right: yield* compile(expression.right),\n      };\n    case \"MemberExpression\": {\n      switch (expression.object.type) {\n        case \"TypeCastExpression\": {\n          const {expression: object, typeAnnotation} = expression.object;\n          const record = yield* Typ.compileIdentifier(\n            typeAnnotation.typeAnnotation,\n          );\n          const field = yield* Typ.getObjectKeyName(expression.property);\n\n          return {\n            type: \"RecordProjection\",\n            field,\n            object: yield* compile(object),\n            record,\n          };\n        }\n        default:\n          return yield* Monad.raise<t>(\n            expression.object,\n            \"Expected a type annotation on this object to access a member\",\n          );\n      }\n    }\n    case \"NullLiteral\":\n      return tt;\n    case \"NumericLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"ObjectExpression\": {\n      if (expression.properties.length === 0) {\n        return tt;\n      }\n\n      return yield* Monad.raise<t>(\n        expression,\n        \"Unhandled object expression without type annotation\",\n      );\n    }\n    /* istanbul ignore next */\n    case \"ParenthesizedExpression\":\n      return yield* compile(expression.expression);\n    case \"StringLiteral\":\n      return {\n        type: \"Constant\",\n        value: expression.value,\n      };\n    case \"TypeCastExpression\": {\n      switch (expression.expression.type) {\n        case \"ObjectExpression\": {\n          const [names, fields] = yield* Monad.reduce(\n            expression.expression.properties,\n            [[], []],\n            function*([names, fields], property) {\n              if (property.type !== \"ObjectProperty\") {\n                return yield* Monad.raise<[*, *]>(\n                  property,\n                  \"Expected a named property\",\n                );\n              }\n\n              if (property.computed) {\n                return yield* Monad.raise<[*, *]>(\n                  property.key,\n                  \"Unhandled computed property name\",\n                );\n              }\n\n              const name = yield* getObjectPropertyName(property);\n              // Because this seems to be the case here and for\n              // performance reasons for the type checking.\n              const value: BabelAst.Expression = (property.value: any);\n\n              if (name === \"type\") {\n                return [\n                  [...names, yield* getStringOfStringLiteral(value)],\n                  fields,\n                ];\n              }\n\n              return [names, [...fields, {name, value: yield* compile(value)}]];\n            },\n          );\n          const typName = yield* Typ.compileIdentifier(\n            expression.typeAnnotation.typeAnnotation,\n          );\n\n          return names.length === 0\n            ? {type: \"RecordInstance\", record: typName, fields}\n            : {\n                type: \"SumInstance\",\n                constr: names[0],\n                fields,\n                sum: typName,\n              };\n        }\n        case \"StringLiteral\": {\n          const {value} = expression.expression;\n\n          return {\n            type: \"EnumInstance\",\n            instance: value,\n            typName: yield* Typ.compileIdentifier(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n          };\n        }\n        default:\n          return {\n            type: \"TypeCastExpression\",\n            expression: yield* compile(expression.expression),\n            typeAnnotation: yield* Typ.compile(\n              expression.typeAnnotation.typeAnnotation,\n            ),\n          };\n      }\n    }\n    case \"UnaryExpression\":\n      return {\n        type: \"UnaryExpression\",\n        argument: yield* compile(expression.argument),\n        operator: expression.operator,\n      };\n    default:\n      return yield* Monad.raiseUnhandled<t>(expression);\n  }\n}\n\nexport function printFunArguments(funArguments: FunArgument[]): Doc.t {\n  return Doc.concat(\n    funArguments.map(({name, typ}) =>\n      Doc.concat([\n        Doc.line,\n        typ\n          ? Doc.group(\n              Doc.concat([\n                \"(\",\n                name,\n                Doc.line,\n                \":\",\n                Doc.line,\n                Typ.print(typ),\n                \")\",\n              ]),\n            )\n          : name,\n      ]),\n    ),\n  );\n}\n\nfunction printRecordInstance(\n  record: string,\n  fields: {name: string, value: Doc.t}[],\n): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"{|\",\n      Doc.indent(\n        Doc.concat(\n          fields.map(({name, value}) =>\n            Doc.concat([\n              Doc.line,\n              Doc.group(\n                Doc.concat([\n                  Doc.group(Doc.concat([`${record}.${name}`, Doc.line, \":=\"])),\n                  Doc.indent(Doc.concat([Doc.line, value, \";\"])),\n                ]),\n              ),\n            ]),\n          ),\n        ),\n      ),\n      Doc.line,\n      \"|}\",\n    ]),\n  );\n}\n\nfunction printLeftValue(lval: LeftValue, withQuote: boolean): Doc.t {\n  switch (lval.type) {\n    case \"Record\":\n      if (lval.fields.length === 0) {\n        return \"_\";\n      }\n\n      return Doc.concat([\n        ...(withQuote ? [\"'\"] : []),\n        printRecordInstance(\n          lval.record,\n          lval.fields.map(({name, variable}) => ({name, value: variable})),\n        ),\n      ]);\n    case \"Variable\":\n      return lval.name;\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nfunction printMatch(\n  discriminant: Doc.t,\n  branches: {\n    body: Doc.t,\n    patterns: {\n      fields: ?(LeftValueRecordField[]),\n      name: string,\n    }[],\n  }[],\n  defaultBranch: ?Doc.t,\n  typName: string,\n): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.group(\n        Doc.concat([\"match\", Doc.line, discriminant, Doc.line, \"with\"]),\n      ),\n      Doc.hardline,\n      ...branches.map(({body, patterns}) =>\n        Doc.group(\n          Doc.concat([\n            Doc.join(\n              Doc.line,\n              patterns.map(({fields, name}) =>\n                Doc.group(\n                  Doc.concat([\n                    \"|\",\n                    Doc.line,\n                    `${typName}.${name}`,\n                    ...(fields\n                      ? [\n                          Doc.line,\n                          printLeftValue(\n                            {\n                              type: \"Record\",\n                              fields,\n                              record: `${typName}.${name}`,\n                            },\n                            false,\n                          ),\n                        ]\n                      : []),\n                  ]),\n                ),\n              ),\n            ),\n            Doc.line,\n            \"=>\",\n            Doc.indent(Doc.concat([Doc.line, body])),\n            Doc.hardline,\n          ]),\n        ),\n      ),\n      ...(defaultBranch\n        ? [\n            Doc.group(\n              Doc.concat([\n                Doc.group(Doc.concat([\"|\", Doc.line, \"_\", Doc.line, \"=>\"])),\n                Doc.indent(Doc.concat([Doc.line, defaultBranch])),\n                Doc.hardline,\n              ]),\n            ),\n          ]\n        : []),\n      \"end\",\n    ]),\n  );\n}\n\nexport function print(needParens: boolean, expression: t): Doc.t {\n  switch (expression.type) {\n    case \"ArrayExpression\":\n      if (expression.elements.length === 0) {\n        return \"[]\";\n      }\n\n      return Doc.group(\n        Doc.concat([\n          \"[\",\n          Doc.indent(\n            Doc.concat([\n              Doc.line,\n              Doc.join(\n                Doc.concat([\";\", Doc.line]),\n                expression.elements.map(element => print(false, element)),\n              ),\n            ]),\n          ),\n          Doc.line,\n          \"]\",\n        ]),\n      );\n    case \"BinaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.join(Doc.line, [\n            print(true, expression.left),\n            expression.operator,\n            print(true, expression.right),\n          ]),\n        ),\n      );\n    case \"CallExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.indent(\n            Doc.join(Doc.line, [\n              print(true, expression.callee),\n              ...expression.arguments.map(argument => print(true, argument)),\n            ]),\n          ),\n        ),\n      );\n    case \"ConditionalExpression\": {\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"if\",\n                Doc.line,\n                print(false, expression.test),\n                Doc.line,\n                \"then\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.consequent)]),\n            ),\n            Doc.line,\n            \"else\",\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.alternate)]),\n            ),\n          ]),\n        ),\n      );\n    }\n    case \"Constant\":\n      return JSON.stringify(expression.value);\n    case \"EnumDestruct\": {\n      const {branches, defaultBranch, discriminant, typName} = expression;\n\n      return printMatch(\n        print(false, discriminant),\n        branches.map(({body, names}) => ({\n          body: print(false, body),\n          patterns: names.map(name => ({fields: null, name})),\n        })),\n        defaultBranch && print(false, defaultBranch),\n        typName,\n      );\n    }\n    case \"EnumInstance\":\n      return `${expression.typName}.${expression.instance}`;\n    case \"FunctionExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            Doc.group(\n              Doc.concat([\n                \"fun\",\n                Doc.indent(\n                  Doc.concat([\n                    ...(expression.value.typParameters.length !== 0\n                      ? [\n                          Doc.line,\n                          Typ.printImplicitTyps(expression.value.typParameters),\n                        ]\n                      : []),\n                    printFunArguments(expression.value.arguments),\n                  ]),\n                ),\n                Doc.line,\n                \"=>\",\n              ]),\n            ),\n            Doc.indent(\n              Doc.concat([Doc.line, print(false, expression.value.body)]),\n            ),\n          ]),\n        ),\n      );\n    case \"Let\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"let\",\n              Doc.line,\n              printLeftValue(expression.lval, true),\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(Doc.concat([Doc.line, print(false, expression.value)])),\n          Doc.line,\n          \"in\",\n          Doc.hardline,\n          print(false, expression.body),\n        ]),\n      );\n    case \"RecordInstance\":\n      return printRecordInstance(\n        expression.record,\n        expression.fields.map(({name, value}) => ({\n          name,\n          value: print(false, value),\n        })),\n      );\n    case \"RecordProjection\":\n      return Doc.group(\n        Doc.concat([\n          print(true, expression.object),\n          Doc.softline,\n          \".(\",\n          Doc.indent(\n            Doc.group(\n              Doc.concat([\n                Doc.softline,\n                expression.record,\n                \".\",\n                expression.field,\n              ]),\n            ),\n          ),\n          Doc.softline,\n          \")\",\n        ]),\n      );\n    case \"SumDestruct\": {\n      const {branches, defaultBranch, discriminant, sum} = expression;\n\n      return printMatch(\n        print(false, discriminant),\n        branches.map(({body, fields, name}) => ({\n          body: print(false, body),\n          patterns: [{fields, name}],\n        })),\n        defaultBranch && print(false, defaultBranch),\n        sum,\n      );\n    }\n    case \"SumInstance\": {\n      const name = `${expression.sum}.${expression.constr}`;\n\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            name,\n            Doc.line,\n            ...(expression.fields.length !== 0\n              ? [\n                  printRecordInstance(\n                    name,\n                    expression.fields.map(({name, value}) => ({\n                      name,\n                      value: print(false, value),\n                    })),\n                  ),\n                ]\n              : [\"tt\"]),\n          ]),\n        ),\n      );\n    }\n    case \"TypeCastExpression\":\n      return Doc.group(\n        Doc.concat([\n          \"(\",\n          Doc.softline,\n          print(true, expression.expression),\n          Doc.line,\n          \":\",\n          Doc.line,\n          Typ.print(expression.typeAnnotation),\n          Doc.softline,\n          \")\",\n        ]),\n      );\n    case \"UnaryExpression\":\n      return Doc.paren(\n        needParens,\n        Doc.group(\n          Doc.concat([\n            expression.operator,\n            Doc.line,\n            print(true, expression.argument),\n          ]),\n        ),\n      );\n    case \"Variable\":\n      return expression.name;\n    /* istanbul ignore next */\n    default:\n      return expression;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as Util from \"./util.js\";\n\ntype Constructor = {name: string, fields: {name: string, typ: Typ.t}[]};\n\nexport type t =\n  | {\n      type: \"Enum\",\n      names: string[],\n    }\n  | {\n      type: \"Record\",\n      fields: {name: string, typ: Typ.t}[],\n    }\n  | {\n      type: \"Sum\",\n      constructors: Constructor[],\n    }\n  | {\n      type: \"Synonym\",\n      typ: Typ.t,\n    };\n\nfunction* getObjectTypePropertyName(\n  property: BabelAst.ObjectTypeProperty,\n): Monad.t<string> {\n  return yield* Typ.getObjectKeyName(property.key);\n}\n\nfunction* getStringOfStringLiteralTypeAnnotation(\n  typ: BabelAst.FlowType,\n): Monad.t<string> {\n  switch (typ.type) {\n    case \"StringLiteralTypeAnnotation\":\n      return typ.value;\n    default:\n      return yield* Monad.raise<string>(typ, \"Expected a string literal\");\n  }\n}\n\nfunction* compileStringEnum(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const names = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"StringLiteralTypeAnnotation\":\n          return typ.value;\n        default:\n          return yield* Monad.raise<string>(\n            typ,\n            \"Only strings are handled in enums\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Enum\",\n    names,\n  };\n}\n\nfunction* compileSumType(typs: BabelAst.FlowType[]): Monad.t<t> {\n  const constructors = yield* Monad.all(\n    typs.map(function*(typ) {\n      switch (typ.type) {\n        case \"ObjectTypeAnnotation\": {\n          const [nameProperties, fieldProperties] = yield* Monad.reduce(\n            typ.properties,\n            [[], []],\n            function*([nameProperties, fieldProperties], property) {\n              if (property.type !== \"ObjectTypeProperty\") {\n                return yield* Monad.raise<[*, *]>(\n                  property,\n                  \"Expected a named property\",\n                );\n              }\n\n              const name = yield* getObjectTypePropertyName(property);\n\n              return name === \"type\"\n                ? [[...nameProperties, property], fieldProperties]\n                : [nameProperties, [...fieldProperties, property]];\n            },\n          );\n\n          if (nameProperties.length === 0) {\n            return yield* Monad.raise<Constructor>(\n              typ,\n              \"Expected at least one field with the name `type`\",\n            );\n          }\n\n          return {\n            name: yield* getStringOfStringLiteralTypeAnnotation(\n              nameProperties[0].value,\n            ),\n            fields: yield* Monad.all(\n              fieldProperties.map(function*(\n                property: BabelAst.ObjectTypeProperty,\n              ) {\n                return {\n                  name: yield* getObjectTypePropertyName(property),\n                  typ: yield* Typ.compile(property.value),\n                };\n              }),\n            ),\n          };\n        }\n        default:\n          return yield* Monad.raise<Constructor>(\n            typ,\n            \"Only objects are handled in sum types\",\n          );\n      }\n    }),\n  );\n\n  return {\n    type: \"Sum\",\n    constructors,\n  };\n}\n\nexport function* compile(typ: BabelAst.FlowType): Monad.t<t> {\n  const plainTyp = yield* Typ.compileIfHandled(typ);\n\n  if (plainTyp) {\n    return {\n      type: \"Synonym\",\n      typ: plainTyp,\n    };\n  }\n\n  switch (typ.type) {\n    case \"ObjectTypeAnnotation\": {\n      const withATypeField = yield* Monad.some(typ.properties, function*(\n        property,\n      ) {\n        switch (property.type) {\n          case \"ObjectTypeProperty\":\n            return (yield* getObjectTypePropertyName(property)) === \"type\";\n          default:\n            return false;\n        }\n      });\n\n      if (withATypeField) {\n        return yield* compileSumType([typ]);\n      }\n\n      const fields = yield* Monad.all(\n        typ.properties.map(function*(property) {\n          if (property.type !== \"ObjectTypeProperty\") {\n            return yield* Monad.raise(property, \"Expected named property\");\n          }\n\n          return {\n            name: yield* getObjectTypePropertyName(property),\n            typ: yield* Typ.compile(property.value),\n          };\n        }),\n      );\n\n      return {\n        type: \"Record\",\n        fields,\n      };\n    }\n    case \"StringLiteralTypeAnnotation\":\n      return yield* compileStringEnum([typ]);\n    case \"UnionTypeAnnotation\": {\n      /* istanbul ignore next */\n      if (typ.types.length === 0) {\n        return {\n          type: \"Synonym\",\n          typ: {\n            type: \"Variable\",\n            name: \"Empty_set\",\n          },\n        };\n      }\n\n      switch (typ.types[0].type) {\n        case \"ObjectTypeAnnotation\":\n          return yield* compileSumType(typ.types);\n        case \"StringLiteralTypeAnnotation\":\n          return yield* compileStringEnum(typ.types);\n        default:\n          return yield* Monad.raise<t>(\n            typ,\n            \"Only handle unions of strings or objects with a `type` field\",\n          );\n      }\n    }\n    default:\n      return yield* Monad.raiseUnhandled<t>(typ);\n  }\n}\n\nfunction printModule(name: string, doc: Doc.t): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      Doc.group(Doc.concat([\"Module\", Doc.line, name, \".\"])),\n      Doc.indent(Doc.concat([Doc.hardline, doc])),\n      Doc.group(Doc.concat([Doc.hardline, \"End\", Doc.line, name, \".\"])),\n    ]),\n  );\n}\n\nfunction printRecord(\n  name: string,\n  fields: {name: string, typ: Typ.t}[],\n): Doc.t {\n  return Doc.concat([\n    Doc.group(\n      Doc.concat([\"Record\", Doc.line, \"t\", Doc.line, \":=\", Doc.line, \"{\"]),\n    ),\n    Doc.indent(\n      Doc.concat(\n        fields.map(({name, typ}) =>\n          Doc.concat([\n            Doc.hardline,\n            name,\n            Doc.line,\n            \":\",\n            Doc.line,\n            Typ.print(typ),\n            Doc.softline,\n            \";\",\n          ]),\n        ),\n      ),\n    ),\n    Doc.hardline,\n    \"}.\",\n  ]);\n}\n\nfunction printDefineTypeAsModule(name: string): Doc.t {\n  return Doc.group(\n    Doc.concat([\n      \"Definition\",\n      Doc.line,\n      name,\n      Doc.line,\n      \":=\",\n      Doc.line,\n      `${name}.t`,\n      \".\",\n    ]),\n  );\n}\n\nexport function print(name: string, typDefinition: t): Doc.t {\n  switch (typDefinition.type) {\n    case \"Enum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.group(Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"])),\n          ...typDefinition.names.map(name =>\n            Doc.group(Doc.concat([Doc.hardline, \"|\", Doc.line, name])),\n          ),\n          \".\",\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Record\":\n      return Doc.concat([\n        printModule(name, printRecord(\"t\", typDefinition.fields)),\n        Doc.hardline,\n        printDefineTypeAsModule(name),\n      ]);\n    case \"Sum\": {\n      const module = printModule(\n        name,\n        Doc.concat([\n          Doc.join(Doc.concat([Doc.hardline, Doc.hardline]), [\n            ...Util.filterMap(typDefinition.constructors, constructor =>\n              constructor.fields.length !== 0\n                ? printModule(\n                    constructor.name,\n                    printRecord(\"t\", constructor.fields),\n                  )\n                : null,\n            ),\n            Doc.group(\n              Doc.concat([\n                Doc.group(\n                  Doc.concat([\"Inductive\", Doc.line, \"t\", Doc.line, \":=\"]),\n                ),\n                ...typDefinition.constructors.map(({name, fields}) =>\n                  Doc.group(\n                    Doc.concat([\n                      Doc.hardline,\n                      \"|\",\n                      Doc.line,\n                      name,\n                      Doc.line,\n                      \"(\",\n                      Doc.softline,\n                      \"_\",\n                      Doc.line,\n                      \":\",\n                      Doc.line,\n                      ...(fields.length !== 0 ? [name, \".t\"] : [\"unit\"]),\n                      Doc.softline,\n                      \")\",\n                    ]),\n                  ),\n                ),\n                \".\",\n              ]),\n            ),\n          ]),\n        ]),\n      );\n\n      return Doc.concat([module, Doc.hardline, printDefineTypeAsModule(name)]);\n    }\n    case \"Synonym\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(\n            Doc.concat([\n              \"Definition\",\n              Doc.line,\n              name,\n              Doc.line,\n              \":\",\n              Doc.line,\n              \"Type\",\n              Doc.line,\n              \":=\",\n            ]),\n          ),\n          Doc.indent(Doc.concat([Doc.line, Typ.print(typDefinition.typ), \".\"])),\n        ]),\n      );\n    /* istanbul ignore next */\n    default:\n      return typDefinition;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Expression from \"./expression.js\";\nimport * as Identifier from \"./identifier.js\";\nimport * as Monad from \"./monad.js\";\nimport * as Typ from \"./typ.js\";\nimport * as TypDefinition from \"./typ-definition.js\";\n\nexport type t =\n  | {\n      type: \"Definition\",\n      arguments: Expression.FunArgument[],\n      body: Expression.t,\n      name: string,\n      returnTyp: ?Typ.t,\n      typParameters: string[],\n    }\n  | {\n      type: \"TypeDefinition\",\n      name: string,\n      typDefinition: TypDefinition.t,\n    };\n\nfunction* extractIdentifierOfLVal(\n  lval: BabelAst.LVal,\n): Monad.t<BabelAst.Identifier> {\n  switch (lval.type) {\n    case \"ArrayPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Array destructuring at top-level is not allowed due to limitations in Coq\",\n      );\n    /* istanbul ignore next */\n    case \"AssignmentPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Unexpected assignement pattern\",\n      );\n    case \"Identifier\":\n      return lval;\n    /* istanbul ignore next */\n    case \"MemberExpression\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Unexpected member expression\",\n      );\n    case \"ObjectPattern\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Object destructuring at top-level is not allowed due to limitations in Coq\",\n      );\n    /* istanbul ignore next */\n    case \"RestElement\":\n      return yield* Monad.raise<BabelAst.Identifier>(\n        lval,\n        \"Rest element unexpected outside a pattern\",\n      );\n    /* istanbul ignore next */\n    default:\n      return lval;\n  }\n}\n\nexport function* compile(declaration: BabelAst.Statement): Monad.t<t[]> {\n  switch (declaration.type) {\n    case \"BlockStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Blocks are not handled at top-level\",\n      );\n    // `break` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"BreakStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `break` at top-level\",\n      );\n    case \"ClassDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Class declarations are not handled\",\n      );\n    // `continue` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ContinueStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `continue` at top-level\",\n      );\n    case \"DebuggerStatement\":\n      return [];\n    case \"DeclareClass\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareVariable\":\n      // We choose to ignore the concept of declaration for now, as we believe\n      // that everything should be public to do proofs.\n      return [];\n    case \"DoWhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Do-while loops are not handled\",\n      );\n    case \"EmptyStatement\":\n      return [];\n    case \"ExportAllDeclaration\":\n      return yield* Monad.raise<t[]>(declaration, \"Export all are not handled\");\n    case \"ExportDefaultDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Export default is not handled\",\n      );\n    case \"ExportNamedDeclaration\":\n      return declaration.declaration\n        ? yield* compile(declaration.declaration)\n        : yield* Monad.raise<t[]>(\n            declaration,\n            \"This kind of export is not handled\",\n          );\n    case \"ExpressionStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level expressions are not handled\",\n      );\n    case \"ForInStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-in loops are not handled\",\n      );\n    case \"ForOfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"For-of loops are not handled\",\n      );\n    case \"ForStatement\":\n      return yield* Monad.raise<t[]>(declaration, \"For loops are not handled\");\n    case \"FunctionDeclaration\": {\n      const fun = yield* Expression.compileFun(declaration);\n      const name = declaration.id\n        ? declaration.id.name\n        : // A top-level function always has a name.\n          /* istanbul ignore next */\n          yield* Monad.raise<string>(declaration, \"Expected named function\");\n\n      return [\n        {\n          type: \"Definition\",\n          arguments: fun.arguments,\n          body: fun.body,\n          name,\n          returnTyp: fun.returnTyp,\n          typParameters: fun.typParameters,\n        },\n      ];\n    }\n    case \"IfStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"If at top-level are not handled\",\n      );\n    case \"ImportDeclaration\": {\n      if (declaration.source.value === \"react\") {\n        return [];\n      }\n\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Only the imports from React are handled\",\n      );\n    }\n    case \"InterfaceDeclaration\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Interface declarations are not handled\",\n      );\n    case \"LabeledStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Labeled statements are not handled\",\n      );\n    case \"OpaqueType\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.impltype),\n        },\n      ];\n    // `return` is forbidden at top-level.\n    /* istanbul ignore next */\n    case \"ReturnStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Unexpected `return` at top-level\",\n      );\n    case \"SwitchStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Top-level switch are not handled\",\n      );\n    case \"ThrowStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Throw statements are not handled\",\n      );\n    case \"TryStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"Try statements are not handled\",\n      );\n    case \"TypeAlias\":\n      return [\n        {\n          type: \"TypeDefinition\",\n          name: Identifier.compile(declaration.id),\n          typDefinition: yield* TypDefinition.compile(declaration.right),\n        },\n      ];\n    case \"VariableDeclaration\":\n      return yield* Monad.all(\n        declaration.declarations.map(function*(declaration) {\n          const id = yield* extractIdentifierOfLVal(declaration.id);\n          const returnTyp = id.typeAnnotation\n            ? id.typeAnnotation.typeAnnotation\n            : null;\n\n          return {\n            type: \"Definition\",\n            arguments: [],\n            body: declaration.init\n              ? yield* Expression.compile(declaration.init)\n              : yield* Monad.raise<Expression.t>(\n                  declaration,\n                  \"Expected definition\",\n                ),\n            name: id.name,\n            returnTyp: returnTyp && (yield* Typ.compile(returnTyp)),\n            typParameters: [],\n          };\n        }),\n      );\n    case \"WhileStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"While loops are not handled\",\n      );\n    // The `with` keyword is forbidden as we are in strict mode.\n    /* istanbul ignore next */\n    case \"WithStatement\":\n      return yield* Monad.raise<t[]>(\n        declaration,\n        \"With statements are not handled\",\n      );\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n\nexport function print(declaration: t): Doc.t {\n  switch (declaration.type) {\n    case \"Definition\":\n      return Doc.group(\n        Doc.concat([\n          Doc.group(Doc.concat([\"Definition\", Doc.line, declaration.name])),\n          Doc.indent(\n            Doc.concat([\n              ...(declaration.typParameters.length !== 0\n                ? [Doc.line, Typ.printImplicitTyps(declaration.typParameters)]\n                : []),\n              Expression.printFunArguments(declaration.arguments),\n              Doc.line,\n              Typ.printReturnTyp(declaration.returnTyp, \":=\"),\n              Doc.hardline,\n              Expression.print(false, declaration.body),\n              \".\",\n            ]),\n          ),\n        ]),\n      );\n    case \"TypeDefinition\":\n      return TypDefinition.print(declaration.name, declaration.typDefinition);\n    /* istanbul ignore next */\n    default:\n      return declaration;\n  }\n}\n","// @flow\nimport * as BabelAst from \"./babel-ast.js\";\nimport * as Doc from \"./doc.js\";\nimport * as Monad from \"./monad.js\";\nimport * as TopLevelStatement from \"./top-level-statement.js\";\n\nexport type t = TopLevelStatement.t[];\n\nexport function* compile(program: BabelAst.Program): Monad.t<t> {\n  const unflattenedStatements = yield* Monad.all(\n    program.body.map(statement => TopLevelStatement.compile(statement)),\n  );\n\n  return unflattenedStatements.reduce(\n    (accumulator: t, statements: TopLevelStatement.t[]) => [\n      ...accumulator,\n      ...statements,\n    ],\n    [],\n  );\n}\n\nexport function print(program: t, withHeader: boolean): Doc.t {\n  return Doc.group(\n    Doc.join(Doc.concat([Doc.hardline, Doc.hardline]), [\n      ...(withHeader\n        ? [\n            `(* Generated by coq-of-js *)\nRequire Import Coq.Lists.List.\nRequire Import Coq.Strings.String.\nRequire Import Coq.ZArith.ZArith.\n\nImport ListNotations.\nLocal Open Scope string.\nLocal Open Scope Z.`,\n          ]\n        : []),\n      ...program.map(programElement => TopLevelStatement.print(programElement)),\n    ]),\n  );\n}\n","// @flow\n\nexport default `/* Basic definitions */\n\nconst\n  b: boolean = false && true,\n  n: number = -12 + 23;\n\nconst s = \"hi\";\n\nconst a = [1, (2 : number), 3];\n\nconst cond = b ? \"a\" : 'b';\n\n/* Functions */\n\nfunction id<A>(x: A): A {\n  return x;\n}\n\nfunction basicTypes(n: number, m: number): string {\n  return \"OK\";\n}\n\nconst r = id(basicTypes(12, 23));\n\nconst f = function<A> (x : A, y : A): bool {\n  return true;\n}\n\nconst arrow = x => x + 1;\n\n/* Records */\n\ntype Rec = {\n  a: string,\n  b: number,\n  c: boolean\n};\n\nconst o = ({a: \"hi\", b: 12, c: false}: Rec);\n\nconst hi = (o: Rec).a;\n\nconst getHi = (o: Rec) => {\n  const {a: hi}: Rec = o;\n  return hi;\n};\n\n/* Enums */\n\ntype Enum = \"aa\" | \"bb\" | \"gg\";\n\nconst aa = (\"aa\": Enum);\n\nfunction getEnumIndex(e: Enum): number {\n  switch ((e: Enum)) {\n    case \"aa\":\n      return 0;\n    case \"bb\":\n      return 1;\n    default:\n      return 2;\n  }\n}\n\n/* Algebraic data types */\n\ntype Status =\n  | {\n      type: \"Error\",\n      message: string,\n    }\n  | {\n      type: \"Loading\",\n    }\n  | {\n      type: \"Nothing\",\n    };\n\nconst status: Status = ({type: \"Error\", message: \"hi\"}: Status);\n\nfunction getMessage(status: Status): string {\n  switch ((status: Status).type) {\n    case \"Error\": {\n      const {message} = status;\n      return message;\n    }\n    case \"Loading\":\n      return \"loading...\";\n    case \"Nothing\":\n      return \"\";\n    default:\n      return (status: empty);\n  }\n}\n`;\n","// @flow\nimport React, {PureComponent} from \"react\";\n\ntype Props = {\n  output: string,\n};\n\nexport default class CoqOutput extends PureComponent<Props> {\n  render() {\n    const {output} = this.props;\n\n    return (\n      <code>\n        <pre>{output}</pre>\n      </code>\n    );\n  }\n}\n","// @flow\nimport React, {PureComponent} from \"react\";\nimport codeFrame from \"babel-code-frame\";\nimport {parse} from \"@babel/parser\";\nimport doc from \"prettier/doc.js\";\nimport * as BabelAst from \"./compiler/babel-ast.js\";\nimport * as Error from \"./compiler/error.js\";\nimport * as Monad from \"./compiler/monad.js\";\nimport * as Program from \"./compiler/program.js\";\nimport demoInput from \"./demoInput.js\";\nimport Output from \"./Output.js\";\nimport \"./App.css\";\n\ntype Props = {};\n\ntype State = {\n  jsInput: string,\n};\n\nfunction getInitialJsInput(): string {\n  if (typeof window !== \"undefined\") {\n    const item = window.sessionStorage.getItem(\"jsInput\");\n\n    return typeof item === \"string\" ? item : demoInput;\n  }\n\n  return demoInput;\n}\n\nexport default class App extends PureComponent<Props, State> {\n  state: State = {\n    jsInput: getInitialJsInput(),\n  };\n\n  onChangeJsInput = (event: SyntheticEvent<HTMLTextAreaElement>) => {\n    const {value} = event.currentTarget;\n\n    this.setState({jsInput: value});\n\n    if (typeof window !== \"undefined\") {\n      window.sessionStorage.setItem(\"jsInput\", value);\n    }\n  };\n\n  getJsAst(jsInput: string): BabelAst.File | string {\n    try {\n      const ast = parse(jsInput, {\n        plugins: [\"flow\", \"jsx\"],\n        sourceType: \"module\",\n      });\n\n      return ast;\n    } catch (error) {\n      const {loc} = error;\n\n      return `${error.message}\\n\\n${codeFrame(jsInput, loc.line, loc.column)}`;\n    }\n  }\n\n  getCoqAst(source: string, jsAst: BabelAst.File): Program.t | string {\n    try {\n      const result = Monad.run(Program.compile(jsAst.program));\n\n      switch (result.type) {\n        case \"Error\":\n          return Error.print(source, result.errors);\n        case \"Success\":\n          return result.value;\n        default:\n          return result;\n      }\n    } catch (error) {\n      return error.message;\n    }\n  }\n\n  getCoqString(coqAst: Program.t): string {\n    return doc.printer.printDocToString(Program.print(coqAst, true), {\n      printWidth: 60,\n      tabWidth: 2,\n    }).formatted;\n  }\n\n  getOutputs(jsInput: string): {coq: string, coqAst: string, jsAst: string} {\n    const jsAst = this.getJsAst(jsInput);\n\n    if (typeof jsAst === \"string\") {\n      return {coq: jsAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    const coqAst = this.getCoqAst(jsInput, jsAst);\n\n    if (typeof coqAst === \"string\") {\n      return {coq: coqAst, coqAst: \"\", jsAst: \"\"};\n    }\n\n    return {\n      coq: this.getCoqString(coqAst),\n      coqAst: JSON.stringify(coqAst, null, 2),\n      jsAst: JSON.stringify(jsAst, null, 2),\n    };\n  }\n\n  render() {\n    const {jsInput} = this.state;\n    const {coq, coqAst, jsAst} = this.getOutputs(jsInput);\n\n    return (\n      <div>\n        <div className=\"header\">\n          <h1>\n            <span className=\"logo\">\n              <span aria-label=\"globe\" role=\"img\">\n                \n              </span>{\" \"}\n              <span aria-label=\"rooster\" role=\"img\">\n                \n              </span>\n            </span>\n            coq-of-js\n            <a className=\"sub-title\" href=\"https://github.com/clarus/coq-of-js\">\n              Sources\n            </a>\n          </h1>\n        </div>\n        <div className=\"split js-source\">\n          <h2>JavaScript editor</h2>\n          <textarea onChange={this.onChangeJsInput} value={jsInput} />\n        </div>\n        <div className=\"split coq-source\">\n          <h2>Generated Coq</h2>\n          <Output output={coq} />\n        </div>\n        <div className=\"split js-ast\">\n          <h2>JavaScript AST</h2>\n          <Output output={jsAst} />\n        </div>\n        <div className=\"split coq-ast\">\n          <h2>Coq AST</h2>\n          <Output output={coqAst} />\n        </div>\n      </div>\n    );\n  }\n}\n","// @flow\nimport {codeFrameColumns} from \"@babel/code-frame\";\nimport * as BabelAst from \"./babel-ast.js\";\n\nexport type t = {\n  location: ?BabelAst.SourceLocation,\n  message: string,\n};\n\nexport function print(source: string, errors: t[]): string {\n  return errors\n    .map(error => {\n      const errorSourceCode = codeFrameColumns(source, error.location);\n\n      return `${errorSourceCode}\\n\\n${error.message}`;\n    })\n    .join(\"\\n\\n**********************\\n\\n\");\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\",\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\",\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\",\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","// @flow\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst rootElement = document.getElementById(\"root\");\n\nif (rootElement) {\n  ReactDOM.render(<App />, rootElement);\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}